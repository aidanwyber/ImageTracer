'use strict';var R=require('concaveman'),F=require('simplify-js'),b=require('fit-curve');function _interopDefault(e){return e&&e.__esModule?e:{default:e}}function _interopNamespace(e){if(e&&e.__esModule)return e;var n=Object.create(null);if(e){Object.keys(e).forEach(function(k){if(k!=='default'){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:true,get:function(){return e[k]}});}})}n.default=e;return Object.freeze(n)}var R__default=/*#__PURE__*/_interopDefault(R);var F__default=/*#__PURE__*/_interopDefault(F);var b__namespace=/*#__PURE__*/_interopNamespace(b);function a(d,t=3){let e=10**t;return (Math.round(d*e)/e).toString()}var x=({x:d,y:t})=>[d,t],$=([d,t])=>({x:d,y:t}),V=class d{constructor(t,e,n,o,i,c){this.color=t;this.sampledPoints=e;this.pathSimplification=n;this.curveFittingTolerance=o;this.width=i;this.height=c;this.color=t,this.width=i,this.height=c,this.curveFittingTolerance=o;let u=e.map(h=>[h.x,h.y]),s=R__default.default(u,d.concavity,1).map(([h,r])=>({x:h,y:r}));this.hullPoints=this.reducePoints(s,n),this.isValid=this.hullPoints.length>=3,this.isValid&&(this.pathSegments=this.createPathSegments(this.hullPoints));}static concavity=1;hullPoints;pathSegments;isValid;reducePoints(t,e){return F__default.default(t,e,true)}createPathSegments(t){let e=[],n=t.length,o=new Array(n),i=true,c=-1;for(let s=0;s<n;s++){let h=t[s],r=t[(s+1)%n],l=this.getBoundarySides(h),g=this.getBoundarySides(r),f=l.some(y=>g.includes(y));l.length>0&&(t[s]=h=this.putOnSide(h,l)),g.length>0&&(t[(s+1)%n]=r=this.putOnSide(r,g));let p=l.length>0&&g.length>0&&f;o[s]=p?0:1,p&&(i=false,c===-1&&(c=s));}c===-1&&(c=0);let u=[{type:o[c],edgeInds:[]}];for(let s=c;s<c+n;s++){let h=s%n,r=(s+1)%n;if(this.isSamePoint(t[h],t[r]))continue;u[u.length-1].edgeInds.push(h),h!==n-1&&o[h]!==o[r]&&u.push({type:o[r],edgeInds:[]});}for(let{type:s,edgeInds:h}of u){if(s===0){for(let p of h)e.push({type:s,points:[t[p],t[(p+1)%n]]});continue}if(h.length===1){e.push({type:0,points:[t[h[0]],t[(h[0]+1)%n]]});continue}let r=h.map(p=>t[p]);r.push(t[(h[h.length-1]+1)%n]);let l=i?b__namespace.createTangent(x(r[1]),x(r[r.length-2])):b__namespace.createTangent(x(r[1]),x(r[0])),g=i?l.map(p=>-p):b__namespace.createTangent(x(r[r.length-2]),x(r[r.length-1])),f=b__namespace.fitCubic(r.map(x),l,g,this.curveFittingTolerance).map(([p,y,m,S])=>({type:1,points:[$(p),$(y),$(m),$(S)]}));for(let p of f)p.points.some(({x:y,y:m})=>isNaN(y)||isNaN(m))&&console.log(`NaN detected:
`,this.color,`
`,r,`
`,l,`
`,g,`
`,p,`
`,r[r.length-2],`
`,r[r.length-1]);e.push(...f);}return e}isBoundaryPoint(t){return this.getBoundarySides(t).length>0}getBoundarySides(t){let e=[],o=this.width-1,i=this.height-1;return Math.abs(t.x-0)<=.5&&e.push(2),Math.abs(t.x-o)<=.5&&e.push(3),Math.abs(t.y-0)<=.5&&e.push(0),Math.abs(t.y-i)<=.5&&e.push(1),e}putOnSide({x:t,y:e},n){let o={x:t,y:e};return n.includes(2)&&(o.x=0),n.includes(3)&&(o.x=this.width),n.includes(0)&&(o.y=0),n.includes(1)&&(o.y=this.height),o}isSamePoint(t,e){return t.x===e.x&&t.y===e.y}getPathData(){if(!this.pathSegments)return "";let t=[],e=this.pathSegments[0];t.push(`M ${a(e.points[0].x)} ${a(e.points[0].y)}`);for(let{type:n,points:o}of this.pathSegments)o.some(i=>isNaN(i.x))&&console.log("NAN:",n===1,o.length),t.push(n===1?`C ${a(o[1].x)} ${a(o[1].y)}, ${a(o[2].x)} ${a(o[2].y)}, ${a(o[3].x)} ${a(o[3].y)}`:n===0?`L ${o[1].x} ${a(o[1].y)}`:"");return t.push("Z"),t.join(" ")}getPathElem(){return this.isValid?`<path fill="rgb(${this.color.r},${this.color.g},${this.color.b})" d="${this.getPathData()}" />
`:""}};var k=class{width;height;curveFittingTolerance;pathSimpMinDist;pixelGridStepSize;validHulls;minHullDistance;debugPointRadius;constructor(t,e,n){if(!t)throw new Error("imageData is required");if(!e?.length)throw new Error("palette must contain at least one color");let{pathSimplificationTolerance:o,curveFittingTolerance:i,minHullDistance:c=3,pixelGridStepSize:u=1,debugPointRadius:s}=n;this.width=t.width,this.height=t.height,this.curveFittingTolerance=i*(Math.max(this.width,this.height)/1e3),this.pathSimpMinDist=Math.max(0,o),this.pixelGridStepSize=Math.max(1,Math.round(u)),this.minHullDistance=c,this.debugPointRadius=s;let h=new Set;e=e.filter(r=>{let l=`${r.r},${r.g},${r.b}`;return h.has(l)?false:(h.add(l),true)}),this.validHulls=this.createHullsFromPalette(t,e);}getHullsByColor(t){return this.validHulls.filter(e=>this.colorsMatch(e.color,t))}getSVGString(t){let e=[`<svg width="${this.width}" height="${this.height}" `,`version="1.1" xmlns="http://www.w3.org/2000/svg">
`];if(t!==void 0){let{r:n,g:o,b:i}=t;e.push(`<rect width="${this.width}" height="${this.height}" x="0" y="0" fill="rgb(${n},${o},${i})" stroke="none" />`);}for(let n of this.validHulls)if(e.push(n.getPathElem()),this.debugPointRadius!==void 0&&n.pathSegments!==void 0){let o=Math.round(this.debugPointRadius*2);for(let i of n.pathSegments){if(i.type===0){let[l,g]=i.points;e.push(`<circle cx="${a(l.x)}" cy="${a(l.y)}" r="${this.debugPointRadius}" fill="#f006" stroke="#f00" />
`),e.push(`<circle cx="${a(g.x)}" cy="${a(g.y)}" r="${this.debugPointRadius/3}" fill="#f00" stroke="none" />
`);let f={x:l.x/2+g.x/2,y:l.y/2+g.y/2};e.push(`<text x="${a(f.x)}" y="${a(f.y)}" style="font: bold ${o}px sans-serif; fill: #f00">L</text>`);continue}let[c,u,s,h]=i.points;e.push(`<circle cx="${a(c.x)}" cy="${a(c.y)}" r="${this.debugPointRadius}" fill="#0006" stroke="#000" />
<circle cx="${a(u.x)}" cy="${a(u.y)}" r="${this.debugPointRadius/2}" fill="none" stroke="#000" />
<circle cx="${a(s.x)}" cy="${a(s.y)}" r="${this.debugPointRadius/2}" fill="none" stroke="#000" />
<circle cx="${a(h.x)}" cy="${a(h.y)}" r="${this.debugPointRadius/3}" fill="#000" stroke="none" />
`);let r={x:c.x/4+h.x/4+u.x/4+s.x/4,y:c.y/4+h.y/4+u.y/4+s.y/4};e.push(`<text x="${a(r.x)}" y="${a(r.y)}" style="font: bold ${o}px sans-serif">C</text>`);}}return e.push("</svg>"),e.join("")}downloadSVG(t,e){if(typeof document>"u"||typeof window>"u")throw new Error("downloadSVG requires a browser environment");t.slice(t.length-4).toLowerCase()!==".svg"&&(t+=".svg");let n=this.getSVGString(e),o=new Blob([n],{type:"image/svg+xml;charset=utf-8"}),i=URL.createObjectURL(o),c=document.createElement("a");c.style.display="none",c.href=i,c.download=t,document.body.appendChild(c),c.click(),document.body.removeChild(c),setTimeout(()=>URL.revokeObjectURL(i),1e4);}createHullsFromPalette(t,e){return e.map(n=>this.createHullsForColor(t,n)).flat().filter(n=>n.isValid)}createHullsForColor(t,e){let n=this.createMaskPointCloud(t,e);return this.separatePointClouds(n).map(i=>new V(e,i,this.pathSimpMinDist,this.curveFittingTolerance,this.width,this.height))}separatePointClouds(t){let e=[];if(t.length===0)return e;let n=Math.max(0,this.minHullDistance);if(this.pixelGridStepSize>n)throw new Error("Pixel grid step needs to be smaller than the minimum hull distance.");let o=n*n,i=n,c=new Map;for(let s=0;s<t.length;s++){let h=t[s],r=Math.floor(h.x/i),l=Math.floor(h.y/i),g=`${r},${l}`;(c.get(g)??c.set(g,[]).get(g)).push(s);}let u=new Uint8Array(t.length);for(let s=0;s<t.length;s++){if(u[s])continue;let h=[],r=[],l=0;for(r.push(s),u[s]=1;l<r.length;){let g=r[l++],f=t[g];h.push(f);let p=Math.floor(f.x/i),y=Math.floor(f.y/i);for(let m=p-1;m<=p+1;m++)for(let S=y-1;S<=y+1;S++){let L=`${m},${S}`,P=c.get(L);if(P)for(let v of P){if(u[v])continue;let M=t[v],w=M.x-f.x,C=M.y-f.y;Math.abs(w)+Math.abs(C)>n*2||w*w+C*C<=o&&(u[v]=1,r.push(v));}}}h.length&&e.push(h);}return e}createMaskPointCloud(t,e){let{data:n,width:o,height:i}=t,c=[],u=this.pixelGridStepSize;for(let s=0;s<i;s+=u)for(let h=0;h<o;h+=u){let r=(s*o+h)*4;this.pixelMatches(n,r,e)&&c.push({x:h,y:s});}return c}pixelMatches(t,e,n){return t[e+3]!==0&&t[e]===n.r&&t[e+1]===n.g&&t[e+2]===n.b}colorsMatch(t,e){return t.r===e.r&&t.g===e.g&&t.b===e.b}};function T(d,t,e){return (t.x-d.x)*(e.y-d.y)-(t.y-d.y)*(e.x-d.x)}function I(d,t){return d.x===t.x&&d.y===t.y}function N(d){if(d.length<=1)return d.slice();let t=d.sort((i,c)=>i.x===c.x?i.y-c.y:i.x-c.x),e=[];for(let i of t)(!e.length||!I(e[e.length-1],i))&&e.push(i);if(e.length<=1)return e.slice();let n=[];for(let i of e){for(;n.length>=2&&T(n[n.length-2],n[n.length-1],i)<=0;)n.pop();n.push(i);}let o=[];for(let i=e.length-1;i>=0;i--){let c=e[i];for(;o.length>=2&&T(o[o.length-2],o[o.length-1],c)<=0;)o.pop();o.push(c);}return n.pop(),o.pop(),n.concat(o)}exports.Hull=V;exports.ImageTrace=k;exports.createConvexHullPoints=N;//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map