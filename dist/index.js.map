{"version":3,"sources":["../src/util.ts","../src/Hull.ts","../src/smoothedSVGPathData.ts","../src/ImageTrace.ts","../src/createConvexHull.ts"],"names":["distSq","a","b","dx","dy","nf","x","precision","k10","Hull","_Hull","color","sampledPoints","smoothingMinLength","arrayPoints","pt","concaveman","y","points","minDist","minDistSq","filteredPoints","smoothedSVGPathData","chaikinSmoothingSteps","width","height","smoothedPoints","applyChaikinSmoothing","catmullRomToBezierPath","options","isClosed","alpha","P","preparePointArray","pathData","i","c1x","c1y","c2x","c2y","calculateBezierControlPoints","iterations","result","chaikinOnce","pts","out","n","end","Q","R","calculateChaikinPoints","p0","p1","p2","p3","t1x","t1y","t2x","t2y","p","q","ImageTrace","imageData","palette","pixelGridStepSize","debugPointRadius","hull","svg","maskPoints","data","stride","index","g","point","c1","c2","cross2","pointsEqual","createConvexHullPoints","pointCloud","sorted","unique","lower","upper"],"mappings":"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","file":"index.js","sourcesContent":["import type { Vec2 } from './types';\r\n\r\n/**\r\n * Calculates the squared distance between two points\r\n */\r\nexport function distSq(a: Vec2, b: Vec2): number {\r\n\tconst dx = a.x - b.x;\r\n\tconst dy = a.y - b.y;\r\n\treturn dx * dx + dy * dy;\r\n}\r\n\r\nexport function nf(x: number, precision = 3): string {\r\n\tconst k10 = 10 ** precision;\r\n\treturn (Math.round(x * k10) / k10).toString();\r\n}\r\n","import type { Color, Vec2 } from './types';\r\nimport { distSq } from './util';\r\n\r\nimport concaveman from 'concaveman';\r\n\r\nexport class Hull {\r\n\tstatic concavity = 1;\r\n\tstatic lengthThreshold = 10;\r\n\r\n\treadonly color: Color;\r\n\treadonly sampledPoints: Vec2[];\r\n\treadonly hullPoints: Vec2[];\r\n\r\n\tconstructor(\r\n\t\tcolor: Color,\r\n\t\tsampledPoints: Vec2[],\r\n\t\tsmoothingMinLength: number\r\n\t) {\r\n\t\tthis.color = color;\r\n\t\tthis.sampledPoints = sampledPoints;\r\n\r\n\t\tconst arrayPoints = sampledPoints.map(pt => [pt.x, pt.y]);\r\n\t\tthis.hullPoints = this.reducePoints(\r\n\t\t\tconcaveman(arrayPoints, Hull.concavity, 1).map(([x, y]) => ({\r\n\t\t\t\tx,\r\n\t\t\t\ty,\r\n\t\t\t})),\r\n\t\t\tsmoothingMinLength\r\n\t\t);\r\n\t\t// more info:\r\n\t\t// https://github.com/mapbox/concaveman\r\n\t}\r\n\r\n\t/**\r\n\t * Reduces the number of points in a path while maintaining its shape\r\n\t */\r\n\treducePoints(points: Vec2[], minDist: number): Vec2[] {\r\n\t\tconst minDistSq = minDist * minDist;\r\n\t\tconst filteredPoints: Vec2[] = [];\r\n\r\n\t\tfor (const pt of points) {\r\n\t\t\tif (\r\n\t\t\t\tfilteredPoints.length === 0 ||\r\n\t\t\t\tdistSq(pt, filteredPoints[filteredPoints.length - 1]) >=\r\n\t\t\t\t\tminDistSq\r\n\t\t\t) {\r\n\t\t\t\tfilteredPoints.push(pt);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (\r\n\t\t\tfilteredPoints.length > 1 &&\r\n\t\t\tdistSq(\r\n\t\t\t\tfilteredPoints[0],\r\n\t\t\t\tfilteredPoints[filteredPoints.length - 1]\r\n\t\t\t) < minDistSq\r\n\t\t) {\r\n\t\t\tfilteredPoints.pop();\r\n\t\t}\r\n\r\n\t\treturn filteredPoints;\r\n\t}\r\n}\r\n","import type { Vec2, SmoothingOptions } from './types';\r\nimport { nf } from './util';\r\n\r\n/**\r\n * Converts an array of 2D points into a smooth SVG path using Catmull-Rom splines\r\n * and Chaikin's corner cutting algorithm.\r\n *\r\n * @param points - Array of Vec2 points to be converted\r\n * @param smoothingMinLength - Minimum length threshold for smoothing\r\n * @param chaikinSmoothingSteps - Number of Chaikin smoothing iterations\r\n * @param width - Canvas width\r\n * @param height - Canvas height\r\n * @returns SVG path data string\r\n */\r\nexport function smoothedSVGPathData(\r\n\tpoints: Vec2[],\r\n\tsmoothingMinLength: number,\r\n\tchaikinSmoothingSteps: number,\r\n\twidth: number,\r\n\theight: number\r\n): string {\r\n\t// const pts = points.map(([x, y]): Vec2 => ({ x, y }));\r\n\tconst smoothedPoints = applyChaikinSmoothing(\r\n\t\tpoints,\r\n\t\tchaikinSmoothingSteps,\r\n\t\ttrue\r\n\t);\r\n\treturn catmullRomToBezierPath(smoothedPoints);\r\n}\r\n\r\n/**\r\n * Converts Catmull-Rom control points into a smooth cubic Bezier SVG path.\r\n *\r\n * @param points - Array of control points\r\n * @param options - Optional configuration for path generation\r\n * @returns SVG path data string\r\n */\r\nexport function catmullRomToBezierPath(\r\n\tpoints: Vec2[],\r\n\toptions: SmoothingOptions = {}\r\n): string {\r\n\tconst { isClosed = true, alpha = 0.5 } = options;\r\n\r\n\tif (points.length < 2) return '';\r\n\r\n\tconst P = preparePointArray(points, isClosed);\r\n\tlet pathData = `M ${nf(points[0].x)} ${nf(points[0].y)}`;\r\n\r\n\tfor (let i = 1; i < P.length - 2; i++) {\r\n\t\tconst [c1x, c1y, c2x, c2y] = calculateBezierControlPoints(\r\n\t\t\tP[i - 1],\r\n\t\t\tP[i],\r\n\t\t\tP[i + 1],\r\n\t\t\tP[i + 2],\r\n\t\t\talpha\r\n\t\t);\r\n\t\tpathData += ` C ${nf(c1x)} ${nf(c1y)}, ${nf(c2x)} ${nf(c2y)}, ${nf(\r\n\t\t\tP[i + 1].x\r\n\t\t)} ${nf(P[i + 1].y)}`;\r\n\t}\r\n\r\n\treturn isClosed ? `${pathData} Z` : pathData;\r\n}\r\n\r\n/**\r\n * Applies multiple iterations of Chaikin's corner-cutting algorithm\r\n *\r\n * @param points - Array of points to smooth\r\n * @param iterations - Number of smoothing iterations\r\n * @param isClosed - Whether the path is closed\r\n * @returns Smoothed array of points\r\n */\r\nfunction applyChaikinSmoothing(\r\n\tpoints: Vec2[],\r\n\titerations: number,\r\n\tisClosed: boolean\r\n): Vec2[] {\r\n\tlet result = points;\r\n\tfor (let i = 0; i < iterations; i++) {\r\n\t\tresult = chaikinOnce(result, isClosed);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Performs one iteration of Chaikin's corner-cutting algorithm\r\n *\r\n * @param pts - Input points\r\n * @param isClosed - Whether the path is closed\r\n * @returns New array of smoothed points\r\n */\r\nfunction chaikinOnce(pts: Vec2[], isClosed: boolean): Vec2[] {\r\n\tconst out: Vec2[] = [];\r\n\tconst n = pts.length;\r\n\r\n\tif (!isClosed) out.push(pts[0]);\r\n\r\n\tconst end = isClosed ? n : n - 1;\r\n\tfor (let i = 0; i < end - 1; i++) {\r\n\t\tconst [Q, R] = calculateChaikinPoints(pts[i], pts[i + 1]);\r\n\t\tout.push(Q, R);\r\n\t}\r\n\r\n\tif (!isClosed) {\r\n\t\tout.push(pts[n - 1]);\r\n\t} else {\r\n\t\tconst [Q, R] = calculateChaikinPoints(pts[n - 1], pts[0]);\r\n\t\tout.push(Q, R);\r\n\t}\r\n\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * Helper function to calculate Bezier control points\r\n */\r\nfunction calculateBezierControlPoints(\r\n\tp0: Vec2,\r\n\tp1: Vec2,\r\n\tp2: Vec2,\r\n\tp3: Vec2,\r\n\talpha: number\r\n): [number, number, number, number] {\r\n\tconst t1x = alpha * (p2.x - p0.x);\r\n\tconst t1y = alpha * (p2.y - p0.y);\r\n\tconst t2x = alpha * (p3.x - p1.x);\r\n\tconst t2y = alpha * (p3.y - p1.y);\r\n\r\n\treturn [p1.x + t1x / 3, p1.y + t1y / 3, p2.x - t2x / 3, p2.y - t2y / 3];\r\n}\r\n\r\n/**\r\n * Helper function to calculate Chaikin points\r\n */\r\nfunction calculateChaikinPoints(p: Vec2, q: Vec2): [Vec2, Vec2] {\r\n\treturn [\r\n\t\t{\r\n\t\t\tx: 0.75 * p.x + 0.25 * q.x,\r\n\t\t\ty: 0.75 * p.y + 0.25 * q.y,\r\n\t\t},\r\n\t\t{\r\n\t\t\tx: 0.25 * p.x + 0.75 * q.x,\r\n\t\t\ty: 0.25 * p.y + 0.75 * q.y,\r\n\t\t},\r\n\t];\r\n}\r\n\r\n/**\r\n * Helper function to prepare point array for path generation\r\n */\r\nfunction preparePointArray(points: Vec2[], isClosed: boolean): Vec2[] {\r\n\tconst P = points.slice();\r\n\tif (isClosed) {\r\n\t\tP.unshift(points[points.length - 1]);\r\n\t\tP.push(points[0], points[1]);\r\n\t} else {\r\n\t\tP.unshift(points[0]);\r\n\t\tP.push(points[points.length - 1]);\r\n\t}\r\n\treturn P;\r\n}\r\n","// import { createHullPoints } from './createHull';\r\nimport type { Color, Vec2, ImageDataLike, ImageTraceOptions } from './types';\r\nimport { Hull } from './Hull';\r\nimport { smoothedSVGPathData } from './smoothedSVGPathData';\r\nimport { nf } from './util';\r\n\r\n/**\r\n * ImageTrace converts raster images to vector graphics by detecting and tracing\r\n * color-matched regions into SVG paths.\r\n */\r\nexport class ImageTrace {\r\n\treadonly width: number;\r\n\treadonly height: number;\r\n\treadonly smoothingMinLength: number;\r\n\treadonly chaikinSmoothingSteps: number;\r\n\treadonly pixelGridStepSize: number;\r\n\treadonly hulls: Hull[];\r\n\treadonly debugPointRadius: number | undefined;\r\n\r\n\t/**\r\n\t * Creates a new ImageTrace instance\r\n\t *\r\n\t * @param imageData - The source image data to trace\r\n\t * @param palette - Array of colors to match against\r\n\t * @param options - Configuration options for tracing\r\n\t * @throws {Error} If imageData or palette is invalid\r\n\t */\r\n\tconstructor(\r\n\t\timageData: ImageDataLike,\r\n\t\tpalette: Color[],\r\n\t\toptions: ImageTraceOptions\r\n\t) {\r\n\t\tif (!imageData) throw new Error('imageData is required');\r\n\t\tif (!palette?.length)\r\n\t\t\tthrow new Error('palette must contain at least one color');\r\n\r\n\t\tconst {\r\n\t\t\tsmoothingMinLength,\r\n\t\t\tchaikinSmoothingSteps,\r\n\t\t\tpixelGridStepSize = 1,\r\n\t\t\tdebugPointRadius,\r\n\t\t} = options;\r\n\r\n\t\tthis.width = imageData.width;\r\n\t\tthis.height = imageData.height;\r\n\t\tthis.smoothingMinLength = smoothingMinLength;\r\n\t\tthis.chaikinSmoothingSteps = chaikinSmoothingSteps;\r\n\t\tthis.pixelGridStepSize = Math.max(1, Math.floor(pixelGridStepSize));\r\n\t\tthis.debugPointRadius = debugPointRadius;\r\n\t\tthis.hulls = this.createHullsFromPalette(imageData, palette);\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves a hull by its color\r\n\t */\r\n\tgetHullByColor(color: Color): Hull | undefined {\r\n\t\treturn this.hulls.find(hull => this.colorsMatch(hull.color, color));\r\n\t}\r\n\r\n\t/**\r\n\t * Generates an SVG string representation of the traced image\r\n\t */\r\n\tgetSVGString(): string {\r\n\t\tconst svg: string[] = [\r\n\t\t\t`<svg width=\"${this.width}\" height=\"${this.height}\" `,\r\n\t\t\t'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ',\r\n\t\t\t'desc=\"Created with VectorCraft\">\\n',\r\n\t\t];\r\n\r\n\t\tfor (const hull of this.hulls) {\r\n\t\t\tsvg.push(this.createPathElement(hull.hullPoints, hull.color));\r\n\r\n\t\t\tif (this.debugPointRadius !== undefined) {\r\n\t\t\t\tsvg.push(this.createPointElements(hull.hullPoints));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsvg.push('</svg>');\r\n\t\treturn svg.join('');\r\n\t}\r\n\r\n\tprivate createHullsFromPalette(\r\n\t\timageData: ImageDataLike,\r\n\t\tpalette: Color[]\r\n\t): Hull[] {\r\n\t\treturn palette.map(color => this.createHullForColor(imageData, color));\r\n\t}\r\n\r\n\tprivate createHullForColor(imageData: ImageDataLike, color: Color): Hull {\r\n\t\tconst maskPoints = this.createMaskPointCloud(imageData, color);\r\n\t\treturn new Hull(color, maskPoints, this.smoothingMinLength);\r\n\t}\r\n\r\n\tprivate createMaskPointCloud(\r\n\t\timageData: ImageDataLike,\r\n\t\tcolor: Color\r\n\t): Vec2[] {\r\n\t\tconst { data, width, height } = imageData;\r\n\t\tconst points: Vec2[] = [];\r\n\t\tconst stride = this.pixelGridStepSize;\r\n\r\n\t\tfor (let y = 0; y < height; y += stride) {\r\n\t\t\tfor (let x = 0; x < width; x += stride) {\r\n\t\t\t\tconst index = (y * width + x) * 4;\r\n\t\t\t\tif (this.pixelMatches(data, index, color)) {\r\n\t\t\t\t\tpoints.push({ x, y });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn points;\r\n\t}\r\n\r\n\tprivate createPathElement(points: Vec2[], color: Color): string {\r\n\t\tconst { r, g, b } = color;\r\n\t\tconst pathData = smoothedSVGPathData(\r\n\t\t\tpoints,\r\n\t\t\tthis.smoothingMinLength,\r\n\t\t\tthis.chaikinSmoothingSteps,\r\n\t\t\tthis.width,\r\n\t\t\tthis.height\r\n\t\t);\r\n\t\treturn `<path fill=\"rgb(${r},${g},${b})\" d=\"${pathData}\" />\\n`;\r\n\t}\r\n\r\n\tprivate createPointElements(points: Vec2[]): string {\r\n\t\treturn points\r\n\t\t\t.map(\r\n\t\t\t\tpoint =>\r\n\t\t\t\t\t`<circle cx=\"${nf(point.x)}\" cy=\"${nf(point.y)}\" ` +\r\n\t\t\t\t\t`r=\"${this.debugPointRadius}\" fill=\"#000\" stroke=\"none\" />\\n`\r\n\t\t\t)\r\n\t\t\t.join('');\r\n\t}\r\n\r\n\tprivate pixelMatches(\r\n\t\tdata: ArrayLike<number>,\r\n\t\tindex: number,\r\n\t\tcolor: Color\r\n\t): boolean {\r\n\t\treturn (\r\n\t\t\tdata[index + 3] !== 0 && // alpha\r\n\t\t\tdata[index] === color.r &&\r\n\t\t\tdata[index + 1] === color.g &&\r\n\t\t\tdata[index + 2] === color.b\r\n\t\t);\r\n\t}\r\n\r\n\tprivate colorsMatch(c1: Color, c2: Color): boolean {\r\n\t\treturn c1.r === c2.r && c1.g === c2.g && c1.b === c2.b;\r\n\t}\r\n}\r\n","import type { Vec2 } from './types';\r\n\r\nfunction cross2(o: Vec2, a: Vec2, b: Vec2): number {\r\n\treturn (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\r\n}\r\n\r\nfunction pointsEqual(a: Vec2, b: Vec2): boolean {\r\n\treturn a.x === b.x && a.y === b.y;\r\n}\r\n\r\nexport function createConvexHullPoints(pointCloud: Vec2[]): Vec2[] {\r\n\tif (pointCloud.length <= 1) {\r\n\t\treturn pointCloud.slice();\r\n\t}\r\n\r\n\tconst sorted = pointCloud.sort((a, b) =>\r\n\t\ta.x === b.x ? a.y - b.y : a.x - b.x\r\n\t);\r\n\r\n\tconst unique: Vec2[] = [];\r\n\tfor (const point of sorted) {\r\n\t\tif (!unique.length || !pointsEqual(unique[unique.length - 1], point)) {\r\n\t\t\tunique.push(point);\r\n\t\t}\r\n\t}\r\n\r\n\tif (unique.length <= 1) {\r\n\t\treturn unique.slice();\r\n\t}\r\n\r\n\tconst lower: Vec2[] = [];\r\n\tfor (const point of unique) {\r\n\t\twhile (\r\n\t\t\tlower.length >= 2 &&\r\n\t\t\tcross2(lower[lower.length - 2], lower[lower.length - 1], point) <= 0\r\n\t\t) {\r\n\t\t\tlower.pop();\r\n\t\t}\r\n\t\tlower.push(point);\r\n\t}\r\n\r\n\tconst upper: Vec2[] = [];\r\n\tfor (let i = unique.length - 1; i >= 0; i--) {\r\n\t\tconst point = unique[i];\r\n\t\twhile (\r\n\t\t\tupper.length >= 2 &&\r\n\t\t\tcross2(upper[upper.length - 2], upper[upper.length - 1], point) <= 0\r\n\t\t) {\r\n\t\t\tupper.pop();\r\n\t\t}\r\n\t\tupper.push(point);\r\n\t}\r\n\r\n\tlower.pop();\r\n\tupper.pop();\r\n\r\n\treturn lower.concat(upper);\r\n}\r\n"]}