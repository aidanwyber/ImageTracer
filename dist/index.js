import k from'concaveman';import H from'simplify-js';import*as y from'fit-curve';function c(p,t=3){let e=10**t;return (Math.round(p*e)/e).toString()}var f=class p{static concavity=1;color;hullPoints;cubics;isValid;constructor(t,e,i,n){this.color=t;let h=e.map(o=>[o.x,o.y]);if(this.hullPoints=this.reducePoints(k(h,p.concavity,1).map(([o,a])=>({x:o,y:a})),i),this.isValid=this.hullPoints.length>=3,this.isValid){let o=({x:r,y:l})=>[r,l],a=([r,l])=>({x:r,y:l}),s=y.createTangent(o(this.hullPoints[1]),o(this.hullPoints[this.hullPoints.length-2]));this.cubics=y.fitCubic(this.hullPoints.map(r=>o(r)),s,s.map(r=>-r),n).map(([r,l,u,d])=>[a(r),a(l),a(u),a(d)]);}}reducePoints(t,e){return H(t,e,true)}getPathData(){if(!this.cubics)return "";let t=[],e=this.cubics[0];t.push(`M ${c(e[0].x)} ${c(e[0].y)}`);for(let i of this.cubics)t.push(`C ${c(i[1].x)} ${c(i[1].y)}, ${c(i[2].x)} ${c(i[2].y)}, ${c(i[3].x)} ${c(i[3].y)}`);return t.push("Z"),t.join(" ")}getPathElem(){return this.isValid?`<path fill="rgb(${this.color.r},${this.color.g},${this.color.b})" d="${this.getPathData()}" />
`:""}};var V=class{width;height;curveFittingTolerance;pathSimpMinDist;pixelGridStepSize;validHulls;minHullDistance;debugPointRadius;constructor(t,e,i){if(!t)throw new Error("imageData is required");if(!e?.length)throw new Error("palette must contain at least one color");let{pathSimplificationTolerance:n,curveFittingTolerance:h,minHullDistance:o=3,pixelGridStepSize:a=1,debugPointRadius:s}=i;this.width=t.width,this.height=t.height,this.curveFittingTolerance=h*(Math.max(this.width,this.height)/1e3),this.pathSimpMinDist=Math.max(0,n),this.pixelGridStepSize=Math.max(1,Math.round(a)),this.minHullDistance=o,this.debugPointRadius=s;let r=new Set;e=e.filter(l=>{let u=`${l.r},${l.g},${l.b}`;return r.has(u)?false:(r.add(u),true)}),this.validHulls=this.createHullsFromPalette(t,e);}getHullsByColor(t){return this.validHulls.filter(e=>this.colorsMatch(e.color,t))}getSVGString(t){let e=[`<svg width="${this.width}" height="${this.height}" `,`version="1.1" xmlns="http://www.w3.org/2000/svg">
`];if(t!==void 0){let{r:i,g:n,b:h}=t;e.push(`<rect width="${this.width}" height="${this.height}" x="0" y="0" fill="rgb(${i},${n},${h})" stroke="none" />`);}for(let i of this.validHulls)if(e.push(i.getPathElem()),this.debugPointRadius!==void 0){for(let n of i.hullPoints)e.push(`<circle cx="${c(n.x)}" cy="${c(n.y)}" r="${this.debugPointRadius}" fill="none" stroke="#000" strokeWeight="${this.debugPointRadius/5}" />
`);if(i.cubics!==void 0)for(let n of i.cubics)e.push(`<circle cx="${c(n[0].x)}" cy="${c(n[0].y)}" r="${this.debugPointRadius}" fill="#000" stroke="none" />
<circle cx="${c(n[1].x)}" cy="${c(n[1].y)}" r="${this.debugPointRadius/2}" fill="#000" stroke="none" />
<circle cx="${c(n[2].x)}" cy="${c(n[2].y)}" r="${this.debugPointRadius/2}" fill="#000" stroke="none" />
`);}return e.push("</svg>"),e.join("")}downloadSVG(t,e){if(typeof document>"u"||typeof window>"u")throw new Error("downloadSVG requires a browser environment");t.slice(t.length-4).toLowerCase()!==".svg"&&(t+=".svg");let i=this.getSVGString(e),n=new Blob([i],{type:"image/svg+xml;charset=utf-8"}),h=URL.createObjectURL(n),o=document.createElement("a");o.style.display="none",o.href=h,o.download=t,document.body.appendChild(o),o.click(),document.body.removeChild(o),setTimeout(()=>URL.revokeObjectURL(h),1e4);}createHullsFromPalette(t,e){return e.map(i=>this.createHullsForColor(t,i)).flat().filter(i=>i.isValid)}createHullsForColor(t,e){let i=this.createMaskPointCloud(t,e);return this.separatePointClouds(i).map(h=>new f(e,h,this.pathSimpMinDist,this.curveFittingTolerance))}separatePointClouds(t){let e=[];if(t.length===0)return e;let i=Math.max(0,this.minHullDistance);if(this.pixelGridStepSize>i)throw new Error("Pixel grid step needs to be smaller than the minimum hull distance.");let n=i*i,h=i,o=new Map;for(let s=0;s<t.length;s++){let r=t[s],l=Math.floor(r.x/h),u=Math.floor(r.y/h),d=`${l},${u}`;(o.get(d)??o.set(d,[]).get(d)).push(s);}let a=new Uint8Array(t.length);for(let s=0;s<t.length;s++){if(a[s])continue;let r=[],l=[],u=0;for(l.push(s),a[s]=1;u<l.length;){let d=l[u++],g=t[d];r.push(g);let w=Math.floor(g.x/h),P=Math.floor(g.y/h);for(let b=w-1;b<=w+1;b++)for(let x=P-1;x<=P+1;x++){let M=`${b},${x}`,C=o.get(M);if(C)for(let m of C){if(a[m])continue;let S=t[m],$=S.x-g.x,v=S.y-g.y;Math.abs($)+Math.abs(v)>i*2||$*$+v*v<=n&&(a[m]=1,l.push(m));}}}r.length&&e.push(r);}return e}createMaskPointCloud(t,e){let{data:i,width:n,height:h}=t,o=[],a=this.pixelGridStepSize;for(let s=0;s<h;s+=a)for(let r=0;r<n;r+=a){let l=(s*n+r)*4;this.pixelMatches(i,l,e)&&o.push({x:r,y:s});}return o}pixelMatches(t,e,i){return t[e+3]!==0&&t[e]===i.r&&t[e+1]===i.g&&t[e+2]===i.b}colorsMatch(t,e){return t.r===e.r&&t.g===e.g&&t.b===e.b}};export{f as Hull,V as ImageTrace,c as nf};//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map