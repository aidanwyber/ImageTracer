{"version":3,"sources":["../src/util.ts","../src/Hull.ts","../src/ImageTrace.ts"],"names":["nf","x","precision","k10","Hull","_Hull","color","sampledPoints","pathSimplification","curveFittingTolerance","arrayPoints","pt","concaveman","y","vec2Arr","arr2Vec","loopTangent","v","a","ca","cb","b","points","tolerance","simplify","data","firstCurve","curve","ImageTrace","imageData","palette","options","pathSimplificationTolerance","minHullDistance","pixelGridStepSize","debugPointRadius","seen","c","key","hull","backgroundColor","svg","r","g","point","fileName","svgText","blob","url","maskPoints","pointCloud","clouds","threshold","thresholdSq","cellSize","grid","i","p","cx","cy","visited","cloud","queue","qi","idx","gx","gy","bucket","nbIdx","q","dx","dy","width","height","stride","index","c1","c2"],"mappings":"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","file":"index.cjs","sourcesContent":["export function nf(x: number, precision = 3): string {\r\n\tconst k10 = 10 ** precision;\r\n\treturn (Math.round(x * k10) / k10).toString();\r\n}\r\n","import type { Color, Vec2 } from './types';\r\n\r\nimport concaveman from 'concaveman';\r\nimport simplify from 'simplify-js';\r\nimport * as FitCurve from 'fit-curve';\r\nimport { nf } from './util';\r\n\r\nexport class Hull {\r\n\tstatic concavity = 1;\r\n\r\n\treadonly color: Color;\r\n\treadonly hullPoints: Vec2[];\r\n\treadonly cubics?: Vec2[][];\r\n\r\n\treadonly isValid: boolean;\r\n\r\n\tconstructor(\r\n\t\tcolor: Color,\r\n\t\tsampledPoints: Vec2[],\r\n\t\tpathSimplification: number,\r\n\t\tcurveFittingTolerance: number\r\n\t) {\r\n\t\tthis.color = color;\r\n\r\n\t\tconst arrayPoints = sampledPoints.map(pt => [pt.x, pt.y]);\r\n\t\tthis.hullPoints = this.reducePoints(\r\n\t\t\tconcaveman(arrayPoints, Hull.concavity, 1).map(([x, y]) => ({\r\n\t\t\t\tx,\r\n\t\t\t\ty,\r\n\t\t\t})),\r\n\t\t\tpathSimplification\r\n\t\t);\r\n\t\t// more info:\r\n\t\t// https://github.com/mapbox/concaveman\r\n\r\n\t\tthis.isValid = this.hullPoints.length >= 3;\r\n\r\n\t\tif (this.isValid) {\r\n\t\t\tconst vec2Arr = ({ x, y }: Vec2) => [x, y];\r\n\t\t\tconst arr2Vec = ([x, y]: number[]) => ({ x, y });\r\n\r\n\t\t\tconst loopTangent = FitCurve.createTangent(\r\n\t\t\t\tvec2Arr(this.hullPoints[1]),\r\n\t\t\t\tvec2Arr(this.hullPoints[this.hullPoints.length - 2])\r\n\t\t\t);\r\n\t\t\tthis.cubics = FitCurve.fitCubic(\r\n\t\t\t\tthis.hullPoints.map(v => vec2Arr(v)),\r\n\t\t\t\tloopTangent,\r\n\t\t\t\tloopTangent.map(x => -x),\r\n\t\t\t\tcurveFittingTolerance\r\n\t\t\t).map(([a, ca, cb, b]) => [\r\n\t\t\t\tarr2Vec(a),\r\n\t\t\t\tarr2Vec(ca),\r\n\t\t\t\tarr2Vec(cb),\r\n\t\t\t\tarr2Vec(b),\r\n\t\t\t]);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Reduces the number of points in a path while maintaining its shape\r\n\t */\r\n\treducePoints(points: Vec2[], tolerance: number): Vec2[] {\r\n\t\treturn simplify(points, tolerance, true);\r\n\t}\r\n\r\n\tgetPathData(): string {\r\n\t\tif (!this.cubics) return '';\r\n\r\n\t\tlet data: string[] = [];\r\n\r\n\t\tconst firstCurve = this.cubics[0];\r\n\t\tdata.push(`M ${nf(firstCurve[0].x)} ${nf(firstCurve[0].y)}`);\r\n\r\n\t\tfor (let curve of this.cubics) {\r\n\t\t\tdata.push(\r\n\t\t\t\t`C ${nf(curve[1].x)} ${nf(curve[1].y)}, ` +\r\n\t\t\t\t\t`${nf(curve[2].x)} ${nf(curve[2].y)}, ` +\r\n\t\t\t\t\t`${nf(curve[3].x)} ${nf(curve[3].y)}`\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tdata.push(`Z`);\r\n\t\treturn data.join(' ');\r\n\t}\r\n\r\n\tgetPathElem(): string {\r\n\t\tif (!this.isValid) return '';\r\n\t\treturn (\r\n\t\t\t`<path fill=\"rgb(${this.color.r},${this.color.g},${this.color.b})\" ` +\r\n\t\t\t`d=\"${this.getPathData()}\" />\\n`\r\n\t\t);\r\n\t}\r\n}\r\n","// import { createHullPoints } from './createHull';\r\nimport type { Color, Vec2, ImageDataLike, ImageTraceOptions } from './types';\r\nimport { Hull } from './Hull';\r\nimport { nf } from './util';\r\n\r\n/**\r\n * ImageTrace converts raster images to vector graphics by detecting and tracing\r\n * color-matched regions into SVG paths.\r\n */\r\nexport class ImageTrace {\r\n\treadonly width: number;\r\n\treadonly height: number;\r\n\treadonly curveFittingTolerance: number;\r\n\treadonly pathSimpMinDist: number;\r\n\treadonly pixelGridStepSize: number;\r\n\treadonly validHulls: Hull[];\r\n\treadonly minHullDistance: number;\r\n\treadonly debugPointRadius?: number;\r\n\r\n\t/**\r\n\t * Creates a new ImageTrace instance\r\n\t *\r\n\t * @param imageData - The source image data to trace\r\n\t * @param palette - Array of colors to match against\r\n\t * @param options - Configuration options for tracing\r\n\t * @throws {Error} If imageData or palette is invalid\r\n\t */\r\n\tconstructor(\r\n\t\timageData: ImageDataLike,\r\n\t\tpalette: Color[],\r\n\t\toptions: ImageTraceOptions\r\n\t) {\r\n\t\tif (!imageData) throw new Error('imageData is required');\r\n\t\tif (!palette?.length)\r\n\t\t\tthrow new Error('palette must contain at least one color');\r\n\r\n\t\tconst {\r\n\t\t\tpathSimplificationTolerance,\r\n\t\t\tcurveFittingTolerance,\r\n\t\t\tminHullDistance = 3,\r\n\t\t\tpixelGridStepSize = 1,\r\n\t\t\tdebugPointRadius,\r\n\t\t} = options;\r\n\r\n\t\tthis.width = imageData.width;\r\n\t\tthis.height = imageData.height;\r\n\t\tthis.curveFittingTolerance =\r\n\t\t\tcurveFittingTolerance * (Math.max(this.width, this.height) / 1000);\r\n\t\tthis.pathSimpMinDist = Math.max(0, pathSimplificationTolerance);\r\n\t\tthis.pixelGridStepSize = Math.max(1, Math.round(pixelGridStepSize));\r\n\t\tthis.minHullDistance = minHullDistance;\r\n\t\tthis.debugPointRadius = debugPointRadius;\r\n\r\n\t\t// remove duplicate colors (preserve first occurrence)\r\n\t\tconst seen = new Set<string>();\r\n\t\tpalette = palette.filter(c => {\r\n\t\t\tconst key = `${c.r},${c.g},${c.b}`;\r\n\t\t\tif (seen.has(key)) return false;\r\n\t\t\tseen.add(key);\r\n\t\t\treturn true;\r\n\t\t});\r\n\t\tthis.validHulls = this.createHullsFromPalette(imageData, palette);\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves a hull by its color\r\n\t */\r\n\tgetHullsByColor(color: Color): Hull[] {\r\n\t\treturn this.validHulls.filter(hull =>\r\n\t\t\tthis.colorsMatch(hull.color, color)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Generates an SVG string representation of the traced image\r\n\t * @param backgroundColor - optional background color to include in the SVG\r\n\t */\r\n\tgetSVGString(backgroundColor?: Color): string {\r\n\t\tconst svg: string[] = [\r\n\t\t\t`<svg width=\"${this.width}\" height=\"${this.height}\" `,\r\n\t\t\t'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\\n',\r\n\t\t];\r\n\r\n\t\tif (backgroundColor !== undefined) {\r\n\t\t\tconst { r, g, b } = backgroundColor;\r\n\t\t\tsvg.push(\r\n\t\t\t\t`<rect width=\"${this.width}\" height=\"${this.height}\" ` +\r\n\t\t\t\t\t`x=\"0\" y=\"0\" fill=\"rgb(${r},${g},${b})\" stroke=\"none\" />`\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tfor (const hull of this.validHulls) {\r\n\t\t\tsvg.push(hull.getPathElem());\r\n\r\n\t\t\tif (this.debugPointRadius !== undefined) {\r\n\t\t\t\tfor (let point of hull.hullPoints) {\r\n\t\t\t\t\tsvg.push(\r\n\t\t\t\t\t\t`<circle cx=\"${nf(point.x)}\" cy=\"${nf(point.y)}\" ` +\r\n\t\t\t\t\t\t\t`r=\"${\r\n\t\t\t\t\t\t\t\tthis.debugPointRadius\r\n\t\t\t\t\t\t\t}\" fill=\"none\" stroke=\"#000\" strokeWeight=\"${\r\n\t\t\t\t\t\t\t\tthis.debugPointRadius / 5\r\n\t\t\t\t\t\t\t}\" />\\n`\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (hull.cubics !== undefined)\r\n\t\t\t\t\tfor (let c of hull.cubics) {\r\n\t\t\t\t\t\tsvg.push(\r\n\t\t\t\t\t\t\t`<circle cx=\"${nf(c[0].x)}\" cy=\"${nf(c[0].y)}\" r=\"${\r\n\t\t\t\t\t\t\t\tthis.debugPointRadius\r\n\t\t\t\t\t\t\t}\" fill=\"#000\" stroke=\"none\" />\\n` +\r\n\t\t\t\t\t\t\t\t`<circle cx=\"${nf(c[1].x)}\" cy=\"${nf(\r\n\t\t\t\t\t\t\t\t\tc[1].y\r\n\t\t\t\t\t\t\t\t)}\" r=\"${\r\n\t\t\t\t\t\t\t\t\tthis.debugPointRadius / 2\r\n\t\t\t\t\t\t\t\t}\" fill=\"#000\" stroke=\"none\" />\\n` +\r\n\t\t\t\t\t\t\t\t`<circle cx=\"${nf(c[2].x)}\" cy=\"${nf(\r\n\t\t\t\t\t\t\t\t\tc[2].y\r\n\t\t\t\t\t\t\t\t)}\" r=\"${\r\n\t\t\t\t\t\t\t\t\tthis.debugPointRadius / 2\r\n\t\t\t\t\t\t\t\t}\" fill=\"#000\" stroke=\"none\" />\\n`\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.push('</svg>');\r\n\t\treturn svg.join('');\r\n\t}\r\n\r\n\t/**\r\n\t * Creates and initiates a download of the SVG generated by getSVGString.\r\n\t * @param fileName - filename for the downloaded file\r\n\t * @param backgroundColor - optional background color to include in the SVG\r\n\t */\r\n\tpublic downloadSVG(fileName: string, backgroundColor?: Color): void {\r\n\t\tif (typeof document === 'undefined' || typeof window === 'undefined') {\r\n\t\t\tthrow new Error('downloadSVG requires a browser environment');\r\n\t\t}\r\n\r\n\t\tif (fileName.slice(fileName.length - 4).toLowerCase() !== '.svg')\r\n\t\t\tfileName += '.svg';\r\n\r\n\t\tconst svgText = this.getSVGString(backgroundColor);\r\n\t\tconst blob = new Blob([svgText], {\r\n\t\t\ttype: 'image/svg+xml;charset=utf-8',\r\n\t\t});\r\n\t\tconst url = URL.createObjectURL(blob);\r\n\r\n\t\tconst a = document.createElement('a');\r\n\t\ta.style.display = 'none';\r\n\t\ta.href = url;\r\n\t\ta.download = fileName;\r\n\r\n\t\tdocument.body.appendChild(a);\r\n\t\ta.click();\r\n\t\tdocument.body.removeChild(a);\r\n\r\n\t\t// revoke the object URL after 10s to ensure the download finished.\r\n\t\tsetTimeout(() => URL.revokeObjectURL(url), 10000);\r\n\t}\r\n\r\n\tprivate createHullsFromPalette(\r\n\t\timageData: ImageDataLike,\r\n\t\tpalette: Color[]\r\n\t): Hull[] {\r\n\t\treturn palette\r\n\t\t\t.map(color => this.createHullsForColor(imageData, color))\r\n\t\t\t.flat()\r\n\t\t\t.filter(hull => hull.isValid);\r\n\t}\r\n\r\n\tprivate createHullsForColor(\r\n\t\timageData: ImageDataLike,\r\n\t\tcolor: Color\r\n\t): Hull[] {\r\n\t\tconst maskPoints = this.createMaskPointCloud(imageData, color);\r\n\t\tconst pointClouds = this.separatePointClouds(maskPoints);\r\n\t\treturn pointClouds.map(\r\n\t\t\tpointCloud =>\r\n\t\t\t\tnew Hull(\r\n\t\t\t\t\tcolor,\r\n\t\t\t\t\tpointCloud,\r\n\t\t\t\t\tthis.pathSimpMinDist,\r\n\t\t\t\t\tthis.curveFittingTolerance\r\n\t\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tprivate separatePointClouds(points: Vec2[]): Vec2[][] {\r\n\t\tconst clouds: Vec2[][] = [];\r\n\t\tif (points.length === 0) return clouds;\r\n\r\n\t\t// Determine an effective threshold that respects both the configured minimum\r\n\t\t// hull distance and the sampling grid step size.\r\n\t\tconst threshold = Math.max(0, this.minHullDistance);\r\n\t\tif (this.pixelGridStepSize > threshold) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Pixel grid step needs to be smaller than the minimum hull distance.'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// We'll compare squared Euclidean distances for the tight membership test.\r\n\t\tconst thresholdSq = threshold * threshold;\r\n\r\n\t\t// Use a spatial hash (grid) to limit neighbor candidate checks.\r\n\t\tconst cellSize = threshold; // one point of distance per cell is sufficient\r\n\t\tconst grid = new Map<string, number[]>();\r\n\t\tfor (let i = 0; i < points.length; i++) {\r\n\t\t\tconst p = points[i];\r\n\t\t\tconst cx = Math.floor(p.x / cellSize);\r\n\t\t\tconst cy = Math.floor(p.y / cellSize);\r\n\t\t\tconst key = `${cx},${cy}`;\r\n\t\t\t// set grid cell (or initialize first)\r\n\t\t\t(grid.get(key) ?? grid.set(key, []).get(key)!).push(i);\r\n\t\t}\r\n\r\n\t\tconst visited = new Uint8Array(points.length);\r\n\r\n\t\tfor (let i = 0; i < points.length; i++) {\r\n\t\t\tif (visited[i]) continue;\r\n\r\n\t\t\t// Start a new cloud\r\n\t\t\tconst cloud: Vec2[] = [];\r\n\t\t\tconst queue: number[] = [];\r\n\t\t\tlet qi = 0;\r\n\t\t\tqueue.push(i);\r\n\t\t\tvisited[i] = 1;\r\n\r\n\t\t\twhile (qi < queue.length) {\r\n\t\t\t\tconst idx = queue[qi++];\r\n\t\t\t\tconst p = points[idx];\r\n\t\t\t\tcloud.push(p);\r\n\r\n\t\t\t\t// Check neighboring grid cells (only need to check adjacent cells because\r\n\t\t\t\t// cellSize == threshold). This keeps candidate lookups small.\r\n\t\t\t\tconst cx = Math.floor(p.x / cellSize);\r\n\t\t\t\tconst cy = Math.floor(p.y / cellSize);\r\n\t\t\t\tfor (let gx = cx - 1; gx <= cx + 1; gx++) {\r\n\t\t\t\t\tfor (let gy = cy - 1; gy <= cy + 1; gy++) {\r\n\t\t\t\t\t\tconst key = `${gx},${gy}`;\r\n\t\t\t\t\t\tconst bucket = grid.get(key);\r\n\t\t\t\t\t\tif (!bucket) continue;\r\n\t\t\t\t\t\tfor (const nbIdx of bucket) {\r\n\t\t\t\t\t\t\tif (visited[nbIdx]) continue;\r\n\t\t\t\t\t\t\tconst q = points[nbIdx];\r\n\t\t\t\t\t\t\tconst dx = q.x - p.x;\r\n\t\t\t\t\t\t\tconst dy = q.y - p.y;\r\n\r\n\t\t\t\t\t\t\t// Fast reject: use Manhattan distance as a cheap filter\r\n\t\t\t\t\t\t\t// because points are integer grid samples. This avoids one\r\n\t\t\t\t\t\t\t// multiplication for far-away candidates.\r\n\t\t\t\t\t\t\tif (Math.abs(dx) + Math.abs(dy) > threshold * 2)\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t// Final check: squared Euclidean distance against threshold^2\r\n\t\t\t\t\t\t\tif (dx * dx + dy * dy <= thresholdSq) {\r\n\t\t\t\t\t\t\t\tvisited[nbIdx] = 1;\r\n\t\t\t\t\t\t\t\tqueue.push(nbIdx);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (cloud.length) clouds.push(cloud);\r\n\t\t}\r\n\r\n\t\treturn clouds;\r\n\t}\r\n\r\n\tprivate createMaskPointCloud(\r\n\t\timageData: ImageDataLike,\r\n\t\tcolor: Color\r\n\t): Vec2[] {\r\n\t\tconst { data, width, height } = imageData;\r\n\t\tconst points: Vec2[] = [];\r\n\t\tconst stride = this.pixelGridStepSize;\r\n\r\n\t\tfor (let y = 0; y < height; y += stride) {\r\n\t\t\tfor (let x = 0; x < width; x += stride) {\r\n\t\t\t\tconst index = (y * width + x) * 4;\r\n\t\t\t\tif (this.pixelMatches(data, index, color)) {\r\n\t\t\t\t\tpoints.push({ x, y });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn points;\r\n\t}\r\n\r\n\tprivate pixelMatches(\r\n\t\tdata: ArrayLike<number>,\r\n\t\tindex: number,\r\n\t\tcolor: Color\r\n\t): boolean {\r\n\t\treturn (\r\n\t\t\tdata[index + 3] !== 0 && // alpha\r\n\t\t\tdata[index] === color.r &&\r\n\t\t\tdata[index + 1] === color.g &&\r\n\t\t\tdata[index + 2] === color.b\r\n\t\t);\r\n\t}\r\n\r\n\tprivate colorsMatch(c1: Color, c2: Color): boolean {\r\n\t\treturn c1.r === c2.r && c1.g === c2.g && c1.b === c2.b;\r\n\t}\r\n}\r\n"]}