{"version":3,"sources":["../src/util.ts","../src/Hull.ts","../src/ImageTrace.ts","../src/createConvexHull.ts"],"names":["nf","x","precision","k10","Hull","_Hull","color","sampledPoints","pathSimplification","curveFittingTolerance","arrayPoints","pt","concaveman","y","vec2Arr","arr2Vec","loopTangent","v","a","ca","cb","b","points","tolerance","simplify","data","firstCurve","curve","ImageTrace","imageData","palette","options","pathSimplificationTolerance","minHullDistance","pixelGridStepSize","debugPointRadius","hull","svg","point","c","maskPoints","pointCloud","clouds","threshold","thresholdSq","cellSize","grid","i","p","cx","cy","key","visited","cloud","queue","qi","idx","gx","gy","bucket","nbIdx","q","dx","dy","width","height","stride","index","c1","c2","cross2","o","pointsEqual","createConvexHullPoints","sorted","unique","lower","upper"],"mappings":"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","file":"index.cjs","sourcesContent":["export function nf(x: number, precision = 3): string {\r\n\tconst k10 = 10 ** precision;\r\n\treturn (Math.round(x * k10) / k10).toString();\r\n}\r\n","import type { Color, Vec2 } from './types';\r\n\r\nimport concaveman from 'concaveman';\r\nimport simplify from 'simplify-js';\r\nimport * as FitCurve from 'fit-curve';\r\nimport { nf } from './util';\r\n\r\nexport class Hull {\r\n\tstatic concavity = 1;\r\n\r\n\treadonly color: Color;\r\n\treadonly hullPoints: Vec2[];\r\n\treadonly cubics?: Vec2[][];\r\n\r\n\treadonly isValid: boolean;\r\n\r\n\tconstructor(\r\n\t\tcolor: Color,\r\n\t\tsampledPoints: Vec2[],\r\n\t\tpathSimplification: number,\r\n\t\tcurveFittingTolerance: number\r\n\t) {\r\n\t\tthis.color = color;\r\n\r\n\t\tconst arrayPoints = sampledPoints.map(pt => [pt.x, pt.y]);\r\n\t\tthis.hullPoints = this.reducePoints(\r\n\t\t\tconcaveman(arrayPoints, Hull.concavity, 1).map(([x, y]) => ({\r\n\t\t\t\tx,\r\n\t\t\t\ty,\r\n\t\t\t})),\r\n\t\t\tpathSimplification\r\n\t\t);\r\n\t\t// more info:\r\n\t\t// https://github.com/mapbox/concaveman\r\n\r\n\t\tthis.isValid = this.hullPoints.length >= 3;\r\n\r\n\t\tif (this.isValid) {\r\n\t\t\tconst vec2Arr = ({ x, y }: Vec2) => [x, y];\r\n\t\t\tconst arr2Vec = ([x, y]: number[]) => ({ x, y });\r\n\r\n\t\t\tconst loopTangent = FitCurve.createTangent(\r\n\t\t\t\tvec2Arr(this.hullPoints[1]),\r\n\t\t\t\tvec2Arr(this.hullPoints[this.hullPoints.length - 2])\r\n\t\t\t);\r\n\t\t\tthis.cubics = FitCurve.fitCubic(\r\n\t\t\t\tthis.hullPoints.map(v => vec2Arr(v)),\r\n\t\t\t\tloopTangent,\r\n\t\t\t\tloopTangent.map(x => -x),\r\n\t\t\t\tcurveFittingTolerance\r\n\t\t\t).map(([a, ca, cb, b]) => [\r\n\t\t\t\tarr2Vec(a),\r\n\t\t\t\tarr2Vec(ca),\r\n\t\t\t\tarr2Vec(cb),\r\n\t\t\t\tarr2Vec(b),\r\n\t\t\t]);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Reduces the number of points in a path while maintaining its shape\r\n\t */\r\n\treducePoints(points: Vec2[], tolerance: number): Vec2[] {\r\n\t\treturn simplify(points, tolerance, true);\r\n\t}\r\n\r\n\tgetPathData(): string {\r\n\t\tif (!this.cubics) return '';\r\n\r\n\t\tlet data: string[] = [];\r\n\r\n\t\tconst firstCurve = this.cubics[0];\r\n\t\tdata.push(`M ${nf(firstCurve[0].x)} ${nf(firstCurve[0].y)}`);\r\n\r\n\t\tfor (let curve of this.cubics) {\r\n\t\t\tdata.push(\r\n\t\t\t\t`C ${nf(curve[1].x)} ${nf(curve[1].y)}, ` +\r\n\t\t\t\t\t`${nf(curve[2].x)} ${nf(curve[2].y)}, ` +\r\n\t\t\t\t\t`${nf(curve[3].x)} ${nf(curve[3].y)}`\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tdata.push(`Z`);\r\n\t\treturn data.join(' ');\r\n\t}\r\n\r\n\tgetPathElem(): string {\r\n\t\tif (!this.isValid) return '';\r\n\t\treturn (\r\n\t\t\t`<path fill=\"rgb(${this.color.r},${this.color.g},${this.color.b})\" ` +\r\n\t\t\t`d=\"${this.getPathData()}\" />\\n`\r\n\t\t);\r\n\t}\r\n}\r\n","// import { createHullPoints } from './createHull';\r\nimport type { Color, Vec2, ImageDataLike, ImageTraceOptions } from './types';\r\nimport { Hull } from './Hull';\r\nimport { nf } from './util';\r\n\r\n/**\r\n * ImageTrace converts raster images to vector graphics by detecting and tracing\r\n * color-matched regions into SVG paths.\r\n */\r\nexport class ImageTrace {\r\n\treadonly width: number;\r\n\treadonly height: number;\r\n\treadonly curveFittingTolerance: number;\r\n\treadonly pathSimpMinDist: number;\r\n\treadonly pixelGridStepSize: number;\r\n\treadonly validHulls: Hull[];\r\n\treadonly minHullDistance: number;\r\n\treadonly debugPointRadius?: number;\r\n\r\n\t/**\r\n\t * Creates a new ImageTrace instance\r\n\t *\r\n\t * @param imageData - The source image data to trace\r\n\t * @param palette - Array of colors to match against\r\n\t * @param options - Configuration options for tracing\r\n\t * @throws {Error} If imageData or palette is invalid\r\n\t */\r\n\tconstructor(\r\n\t\timageData: ImageDataLike,\r\n\t\tpalette: Color[],\r\n\t\toptions: ImageTraceOptions\r\n\t) {\r\n\t\tif (!imageData) throw new Error('imageData is required');\r\n\t\tif (!palette?.length)\r\n\t\t\tthrow new Error('palette must contain at least one color');\r\n\r\n\t\tconst {\r\n\t\t\tpathSimplificationTolerance,\r\n\t\t\tcurveFittingTolerance,\r\n\t\t\tminHullDistance = 3,\r\n\t\t\tpixelGridStepSize = 1,\r\n\t\t\tdebugPointRadius,\r\n\t\t} = options;\r\n\r\n\t\tthis.width = imageData.width;\r\n\t\tthis.height = imageData.height;\r\n\t\tthis.curveFittingTolerance =\r\n\t\t\tcurveFittingTolerance * (Math.max(this.width, this.height) / 1000);\r\n\t\tthis.pathSimpMinDist = Math.max(0, pathSimplificationTolerance);\r\n\t\tthis.pixelGridStepSize = Math.max(1, Math.round(pixelGridStepSize));\r\n\t\tthis.minHullDistance = minHullDistance;\r\n\t\tthis.debugPointRadius = debugPointRadius;\r\n\t\tthis.validHulls = this.createHullsFromPalette(imageData, palette);\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves a hull by its color\r\n\t */\r\n\tgetHullsByColor(color: Color): Hull | undefined {\r\n\t\treturn this.validHulls.find(hull =>\r\n\t\t\tthis.colorsMatch(hull.color, color)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Generates an SVG string representation of the traced image\r\n\t */\r\n\tgetSVGString(): string {\r\n\t\tconst svg: string[] = [\r\n\t\t\t`<svg width=\"${this.width}\" height=\"${this.height}\" `,\r\n\t\t\t'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\\n',\r\n\t\t];\r\n\t\tfor (const hull of this.validHulls) {\r\n\t\t\tsvg.push(hull.getPathElem());\r\n\r\n\t\t\tif (this.debugPointRadius !== undefined) {\r\n\t\t\t\tfor (let point of hull.hullPoints) {\r\n\t\t\t\t\tsvg.push(\r\n\t\t\t\t\t\t`<circle cx=\"${nf(point.x)}\" cy=\"${nf(point.y)}\" ` +\r\n\t\t\t\t\t\t\t`r=\"${\r\n\t\t\t\t\t\t\t\tthis.debugPointRadius\r\n\t\t\t\t\t\t\t}\" fill=\"none\" stroke=\"#000\" strokeWeight=\"${\r\n\t\t\t\t\t\t\t\tthis.debugPointRadius / 5\r\n\t\t\t\t\t\t\t}\" />\\n`\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (hull.cubics !== undefined)\r\n\t\t\t\t\tfor (let c of hull.cubics) {\r\n\t\t\t\t\t\tsvg.push(\r\n\t\t\t\t\t\t\t`<circle cx=\"${nf(c[0].x)}\" cy=\"${nf(c[0].y)}\" r=\"${\r\n\t\t\t\t\t\t\t\tthis.debugPointRadius\r\n\t\t\t\t\t\t\t}\" fill=\"#000\" stroke=\"none\" />\\n` +\r\n\t\t\t\t\t\t\t\t`<circle cx=\"${nf(c[1].x)}\" cy=\"${nf(\r\n\t\t\t\t\t\t\t\t\tc[1].y\r\n\t\t\t\t\t\t\t\t)}\" r=\"${\r\n\t\t\t\t\t\t\t\t\tthis.debugPointRadius / 2\r\n\t\t\t\t\t\t\t\t}\" fill=\"#000\" stroke=\"none\" />\\n` +\r\n\t\t\t\t\t\t\t\t`<circle cx=\"${nf(c[2].x)}\" cy=\"${nf(\r\n\t\t\t\t\t\t\t\t\tc[2].y\r\n\t\t\t\t\t\t\t\t)}\" r=\"${\r\n\t\t\t\t\t\t\t\t\tthis.debugPointRadius / 2\r\n\t\t\t\t\t\t\t\t}\" fill=\"#000\" stroke=\"none\" />\\n`\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.push('</svg>');\r\n\t\treturn svg.join('');\r\n\t}\r\n\r\n\tprivate createHullsFromPalette(\r\n\t\timageData: ImageDataLike,\r\n\t\tpalette: Color[]\r\n\t): Hull[] {\r\n\t\treturn palette\r\n\t\t\t.map(color => this.createHullsForColor(imageData, color))\r\n\t\t\t.flat()\r\n\t\t\t.filter(hull => hull.isValid);\r\n\t}\r\n\r\n\tprivate createHullsForColor(\r\n\t\timageData: ImageDataLike,\r\n\t\tcolor: Color\r\n\t): Hull[] {\r\n\t\tconst maskPoints = this.createMaskPointCloud(imageData, color);\r\n\t\tconst pointClouds = this.separatePointClouds(maskPoints);\r\n\t\treturn pointClouds.map(\r\n\t\t\tpointCloud =>\r\n\t\t\t\tnew Hull(\r\n\t\t\t\t\tcolor,\r\n\t\t\t\t\tpointCloud,\r\n\t\t\t\t\tthis.pathSimpMinDist,\r\n\t\t\t\t\tthis.curveFittingTolerance\r\n\t\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tprivate separatePointClouds(points: Vec2[]): Vec2[][] {\r\n\t\tconst clouds: Vec2[][] = [];\r\n\t\tif (points.length === 0) return clouds;\r\n\r\n\t\t// Determine an effective threshold that respects both the configured minimum\r\n\t\t// hull distance and the sampling grid step size.\r\n\t\tconst threshold = Math.max(0, this.minHullDistance);\r\n\t\tif (this.pixelGridStepSize > threshold) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Pixel grid step needs to be smaller than the minimum hull distance.'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// We'll compare squared Euclidean distances for the tight membership test.\r\n\t\tconst thresholdSq = threshold * threshold;\r\n\r\n\t\t// Use a spatial hash (grid) to limit neighbor candidate checks.\r\n\t\tconst cellSize = threshold; // one point of distance per cell is sufficient\r\n\t\tconst grid = new Map<string, number[]>();\r\n\t\tfor (let i = 0; i < points.length; i++) {\r\n\t\t\tconst p = points[i];\r\n\t\t\tconst cx = Math.floor(p.x / cellSize);\r\n\t\t\tconst cy = Math.floor(p.y / cellSize);\r\n\t\t\tconst key = `${cx},${cy}`;\r\n\t\t\t// set grid cell (or initialize first)\r\n\t\t\t(grid.get(key) ?? grid.set(key, []).get(key)!).push(i);\r\n\t\t}\r\n\r\n\t\tconst visited = new Uint8Array(points.length);\r\n\r\n\t\tfor (let i = 0; i < points.length; i++) {\r\n\t\t\tif (visited[i]) continue;\r\n\r\n\t\t\t// Start a new cloud\r\n\t\t\tconst cloud: Vec2[] = [];\r\n\t\t\tconst queue: number[] = [];\r\n\t\t\tlet qi = 0;\r\n\t\t\tqueue.push(i);\r\n\t\t\tvisited[i] = 1;\r\n\r\n\t\t\twhile (qi < queue.length) {\r\n\t\t\t\tconst idx = queue[qi++];\r\n\t\t\t\tconst p = points[idx];\r\n\t\t\t\tcloud.push(p);\r\n\r\n\t\t\t\t// Check neighboring grid cells (only need to check adjacent cells because\r\n\t\t\t\t// cellSize == threshold). This keeps candidate lookups small.\r\n\t\t\t\tconst cx = Math.floor(p.x / cellSize);\r\n\t\t\t\tconst cy = Math.floor(p.y / cellSize);\r\n\t\t\t\tfor (let gx = cx - 1; gx <= cx + 1; gx++) {\r\n\t\t\t\t\tfor (let gy = cy - 1; gy <= cy + 1; gy++) {\r\n\t\t\t\t\t\tconst key = `${gx},${gy}`;\r\n\t\t\t\t\t\tconst bucket = grid.get(key);\r\n\t\t\t\t\t\tif (!bucket) continue;\r\n\t\t\t\t\t\tfor (const nbIdx of bucket) {\r\n\t\t\t\t\t\t\tif (visited[nbIdx]) continue;\r\n\t\t\t\t\t\t\tconst q = points[nbIdx];\r\n\t\t\t\t\t\t\tconst dx = q.x - p.x;\r\n\t\t\t\t\t\t\tconst dy = q.y - p.y;\r\n\r\n\t\t\t\t\t\t\t// Fast reject: use Manhattan distance as a cheap filter\r\n\t\t\t\t\t\t\t// because points are integer grid samples. This avoids one\r\n\t\t\t\t\t\t\t// multiplication for far-away candidates.\r\n\t\t\t\t\t\t\tif (Math.abs(dx) + Math.abs(dy) > threshold * 2)\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t// Final check: squared Euclidean distance against threshold^2\r\n\t\t\t\t\t\t\tif (dx * dx + dy * dy <= thresholdSq) {\r\n\t\t\t\t\t\t\t\tvisited[nbIdx] = 1;\r\n\t\t\t\t\t\t\t\tqueue.push(nbIdx);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (cloud.length) clouds.push(cloud);\r\n\t\t}\r\n\r\n\t\treturn clouds;\r\n\t}\r\n\r\n\tprivate createMaskPointCloud(\r\n\t\timageData: ImageDataLike,\r\n\t\tcolor: Color\r\n\t): Vec2[] {\r\n\t\tconst { data, width, height } = imageData;\r\n\t\tconst points: Vec2[] = [];\r\n\t\tconst stride = this.pixelGridStepSize;\r\n\r\n\t\tfor (let y = 0; y < height; y += stride) {\r\n\t\t\tfor (let x = 0; x < width; x += stride) {\r\n\t\t\t\tconst index = (y * width + x) * 4;\r\n\t\t\t\tif (this.pixelMatches(data, index, color)) {\r\n\t\t\t\t\tpoints.push({ x, y });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn points;\r\n\t}\r\n\r\n\tprivate pixelMatches(\r\n\t\tdata: ArrayLike<number>,\r\n\t\tindex: number,\r\n\t\tcolor: Color\r\n\t): boolean {\r\n\t\treturn (\r\n\t\t\tdata[index + 3] !== 0 && // alpha\r\n\t\t\tdata[index] === color.r &&\r\n\t\t\tdata[index + 1] === color.g &&\r\n\t\t\tdata[index + 2] === color.b\r\n\t\t);\r\n\t}\r\n\r\n\tprivate colorsMatch(c1: Color, c2: Color): boolean {\r\n\t\treturn c1.r === c2.r && c1.g === c2.g && c1.b === c2.b;\r\n\t}\r\n}\r\n","import type { Vec2 } from './types';\r\n\r\nfunction cross2(o: Vec2, a: Vec2, b: Vec2): number {\r\n\treturn (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\r\n}\r\n\r\nfunction pointsEqual(a: Vec2, b: Vec2): boolean {\r\n\treturn a.x === b.x && a.y === b.y;\r\n}\r\n\r\nexport function createConvexHullPoints(pointCloud: Vec2[]): Vec2[] {\r\n\tif (pointCloud.length <= 1) {\r\n\t\treturn pointCloud.slice();\r\n\t}\r\n\r\n\tconst sorted = pointCloud.sort((a, b) =>\r\n\t\ta.x === b.x ? a.y - b.y : a.x - b.x\r\n\t);\r\n\r\n\tconst unique: Vec2[] = [];\r\n\tfor (const point of sorted) {\r\n\t\tif (!unique.length || !pointsEqual(unique[unique.length - 1], point)) {\r\n\t\t\tunique.push(point);\r\n\t\t}\r\n\t}\r\n\r\n\tif (unique.length <= 1) {\r\n\t\treturn unique.slice();\r\n\t}\r\n\r\n\tconst lower: Vec2[] = [];\r\n\tfor (const point of unique) {\r\n\t\twhile (\r\n\t\t\tlower.length >= 2 &&\r\n\t\t\tcross2(lower[lower.length - 2], lower[lower.length - 1], point) <= 0\r\n\t\t) {\r\n\t\t\tlower.pop();\r\n\t\t}\r\n\t\tlower.push(point);\r\n\t}\r\n\r\n\tconst upper: Vec2[] = [];\r\n\tfor (let i = unique.length - 1; i >= 0; i--) {\r\n\t\tconst point = unique[i];\r\n\t\twhile (\r\n\t\t\tupper.length >= 2 &&\r\n\t\t\tcross2(upper[upper.length - 2], upper[upper.length - 1], point) <= 0\r\n\t\t) {\r\n\t\t\tupper.pop();\r\n\t\t}\r\n\t\tupper.push(point);\r\n\t}\r\n\r\n\tlower.pop();\r\n\tupper.pop();\r\n\r\n\treturn lower.concat(upper);\r\n}\r\n"]}