import H from'concaveman';import R from'simplify-js';import*as y from'fit-curve';function h(u,e=3){let t=10**e;return (Math.round(u*t)/t).toString()}var m=class u{static concavity=1;color;hullPoints;cubics;isValid;constructor(e,t,i,o){this.color=e;let r=t.map(n=>[n.x,n.y]);if(this.hullPoints=this.reducePoints(H(r,u.concavity,1).map(([n,a])=>({x:n,y:a})),i),this.isValid=this.hullPoints.length>=3,this.isValid){let n=({x:s,y:c})=>[s,c],a=([s,c])=>({x:s,y:c}),l=y.createTangent(n(this.hullPoints[1]),n(this.hullPoints[this.hullPoints.length-2]));this.cubics=y.fitCubic(this.hullPoints.map(s=>n(s)),l,l.map(s=>-s),o).map(([s,c,d,p])=>[a(s),a(c),a(d),a(p)]);}}reducePoints(e,t){return R(e,t,true)}getPathData(){if(!this.cubics)return "";let e=[],t=this.cubics[0];e.push(`M ${h(t[0].x)} ${h(t[0].y)}`);for(let i of this.cubics)e.push(`C ${h(i[1].x)} ${h(i[1].y)}, ${h(i[2].x)} ${h(i[2].y)}, ${h(i[3].x)} ${h(i[3].y)}`);return e.push("Z"),e.join(" ")}getPathElem(){return this.isValid?`<path fill="rgb(${this.color.r},${this.color.g},${this.color.b})" d="${this.getPathData()}" />
`:""}};var S=class{width;height;curveFittingTolerance;pathSimpMinDist;pixelGridStepSize;validHulls;minHullDistance;debugPointRadius;constructor(e,t,i){if(!e)throw new Error("imageData is required");if(!t?.length)throw new Error("palette must contain at least one color");let{pathSimplificationTolerance:o,curveFittingTolerance:r,minHullDistance:n=3,pixelGridStepSize:a=1,debugPointRadius:l}=i;this.width=e.width,this.height=e.height,this.curveFittingTolerance=r*(Math.max(this.width,this.height)/1e3),this.pathSimpMinDist=Math.max(0,o),this.pixelGridStepSize=Math.max(1,Math.round(a)),this.minHullDistance=n,this.debugPointRadius=l;let s=new Set;t=t.filter(c=>{let d=`${c.r},${c.g},${c.b}`;return s.has(d)?false:(s.add(d),true)}),this.validHulls=this.createHullsFromPalette(e,t);}getHullsByColor(e){return this.validHulls.filter(t=>this.colorsMatch(t.color,e))}getSVGString(e){let t=[`<svg width="${this.width}" height="${this.height}" `,`version="1.1" xmlns="http://www.w3.org/2000/svg">
`];if(e!==void 0){let{r:i,g:o,b:r}=e;t.push(`<rect width="${this.width}" height="${this.height}" x="0" y="0" fill="rgb(${i},${o},${r})" stroke="none" />`);}for(let i of this.validHulls)if(t.push(i.getPathElem()),this.debugPointRadius!==void 0){for(let o of i.hullPoints)t.push(`<circle cx="${h(o.x)}" cy="${h(o.y)}" r="${this.debugPointRadius}" fill="none" stroke="#000" strokeWeight="${this.debugPointRadius/5}" />
`);if(i.cubics!==void 0)for(let o of i.cubics)t.push(`<circle cx="${h(o[0].x)}" cy="${h(o[0].y)}" r="${this.debugPointRadius}" fill="#000" stroke="none" />
<circle cx="${h(o[1].x)}" cy="${h(o[1].y)}" r="${this.debugPointRadius/2}" fill="#000" stroke="none" />
<circle cx="${h(o[2].x)}" cy="${h(o[2].y)}" r="${this.debugPointRadius/2}" fill="#000" stroke="none" />
`);}return t.push("</svg>"),t.join("")}downloadSVG(e,t){if(typeof document>"u"||typeof window>"u")throw new Error("downloadSVG requires a browser environment");e.slice(e.length-4).toLowerCase()!==".svg"&&(e+=".svg");let i=this.getSVGString(t),o=new Blob([i],{type:"image/svg+xml;charset=utf-8"}),r=URL.createObjectURL(o),n=document.createElement("a");n.style.display="none",n.href=r,n.download=e,document.body.appendChild(n),n.click(),document.body.removeChild(n),setTimeout(()=>URL.revokeObjectURL(r),1e4);}createHullsFromPalette(e,t){return t.map(i=>this.createHullsForColor(e,i)).flat().filter(i=>i.isValid)}createHullsForColor(e,t){let i=this.createMaskPointCloud(e,t);return this.separatePointClouds(i).map(r=>new m(t,r,this.pathSimpMinDist,this.curveFittingTolerance))}separatePointClouds(e){let t=[];if(e.length===0)return t;let i=Math.max(0,this.minHullDistance);if(this.pixelGridStepSize>i)throw new Error("Pixel grid step needs to be smaller than the minimum hull distance.");let o=i*i,r=i,n=new Map;for(let l=0;l<e.length;l++){let s=e[l],c=Math.floor(s.x/r),d=Math.floor(s.y/r),p=`${c},${d}`;(n.get(p)??n.set(p,[]).get(p)).push(l);}let a=new Uint8Array(e.length);for(let l=0;l<e.length;l++){if(a[l])continue;let s=[],c=[],d=0;for(c.push(l),a[l]=1;d<c.length;){let p=c[d++],g=e[p];s.push(g);let w=Math.floor(g.x/r),V=Math.floor(g.y/r);for(let x=w-1;x<=w+1;x++)for(let b=V-1;b<=V+1;b++){let k=`${x},${b}`,P=n.get(k);if(P)for(let f of P){if(a[f])continue;let C=e[f],$=C.x-g.x,v=C.y-g.y;Math.abs($)+Math.abs(v)>i*2||$*$+v*v<=o&&(a[f]=1,c.push(f));}}}s.length&&t.push(s);}return t}createMaskPointCloud(e,t){let{data:i,width:o,height:r}=e,n=[],a=this.pixelGridStepSize;for(let l=0;l<r;l+=a)for(let s=0;s<o;s+=a){let c=(l*o+s)*4;this.pixelMatches(i,c,t)&&n.push({x:s,y:l});}return n}pixelMatches(e,t,i){return e[t+3]!==0&&e[t]===i.r&&e[t+1]===i.g&&e[t+2]===i.b}colorsMatch(e,t){return e.r===t.r&&e.g===t.g&&e.b===t.b}};function M(u,e,t){return (e.x-u.x)*(t.y-u.y)-(e.y-u.y)*(t.x-u.x)}function D(u,e){return u.x===e.x&&u.y===e.y}function U(u){if(u.length<=1)return u.slice();let e=u.sort((r,n)=>r.x===n.x?r.y-n.y:r.x-n.x),t=[];for(let r of e)(!t.length||!D(t[t.length-1],r))&&t.push(r);if(t.length<=1)return t.slice();let i=[];for(let r of t){for(;i.length>=2&&M(i[i.length-2],i[i.length-1],r)<=0;)i.pop();i.push(r);}let o=[];for(let r=t.length-1;r>=0;r--){let n=t[r];for(;o.length>=2&&M(o[o.length-2],o[o.length-1],n)<=0;)o.pop();o.push(n);}return i.pop(),o.pop(),i.concat(o)}export{m as Hull,S as ImageTrace,U as createConvexHullPoints};//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map