// import { createHullPoints } from './createHull';
import type { Color, Vec2, ImageDataLike, ImageTraceOptions } from './types';
import { Hull } from './Hull';
import { nf } from './util';

/**
 * ImageTrace converts raster images to vector graphics by detecting and tracing
 * color-matched regions into SVG paths.
 */
export class ImageTrace {
	readonly width: number;
	readonly height: number;
	readonly curveFittingTolerance: number;
	readonly pathSimpMinDist: number;
	readonly pixelGridStepSize: number;
	readonly validHulls: Hull[];
	readonly minHullDistance: number;
	readonly debugPointRadius?: number;

	/**
	 * Creates a new ImageTrace instance
	 *
	 * @param imageData - The source image data to trace
	 * @param palette - Array of colors to match against
	 * @param options - Configuration options for tracing
	 * @throws {Error} If imageData or palette is invalid
	 */
	constructor(
		imageData: ImageDataLike,
		palette: Color[],
		options: ImageTraceOptions
	) {
		if (!imageData) throw new Error('imageData is required');
		if (!palette?.length)
			throw new Error('palette must contain at least one color');

		const {
			pathSimplificationTolerance,
			curveFittingTolerance,
			minHullDistance = 3,
			pixelGridStepSize = 1,
			debugPointRadius,
		} = options;

		this.width = imageData.width;
		this.height = imageData.height;
		this.curveFittingTolerance =
			curveFittingTolerance * (Math.max(this.width, this.height) / 1000);
		this.pathSimpMinDist = Math.max(0, pathSimplificationTolerance);
		this.pixelGridStepSize = Math.max(1, Math.round(pixelGridStepSize));
		this.minHullDistance = minHullDistance;
		this.debugPointRadius = debugPointRadius;

		// remove duplicate colors (preserve first occurrence)
		const seen = new Set<string>();
		palette = palette.filter(c => {
			const key = `${c.r},${c.g},${c.b}`;
			if (seen.has(key)) return false;
			seen.add(key);
			return true;
		});
		this.validHulls = this.createHullsFromPalette(imageData, palette);
	}

	/**
	 * Retrieves a hull by its color
	 */
	getHullsByColor(color: Color): Hull[] {
		return this.validHulls.filter(hull =>
			this.colorsMatch(hull.color, color)
		);
	}

	/**
	 * Generates an SVG string representation of the traced image
	 * @param backgroundColor - optional background color to include in the SVG
	 */
	getSVGString(backgroundColor?: Color): string {
		const svg: string[] = [
			`<svg width="${this.width}" height="${this.height}" `,
			'version="1.1" xmlns="http://www.w3.org/2000/svg">\n',
		];

		if (backgroundColor !== undefined) {
			const { r, g, b } = backgroundColor;
			svg.push(
				`<rect width="${this.width}" height="${this.height}" ` +
					`x="0" y="0" fill="rgb(${r},${g},${b})" stroke="none" />`
			);
		}

		for (const hull of this.validHulls) {
			svg.push(hull.getPathElem());

			if (this.debugPointRadius !== undefined) {
				for (let point of hull.hullPoints) {
					svg.push(
						`<circle cx="${nf(point.x)}" cy="${nf(point.y)}" ` +
							`r="${
								this.debugPointRadius
							}" fill="none" stroke="#000" strokeWeight="${
								this.debugPointRadius / 5
							}" />\n`
					);
				}

                                if (hull.pathSegments !== undefined)
                                        for (let segment of hull.pathSegments) {
                                                if (segment.type !== 'C') continue;

                                                const [start, c1, c2] = segment.points;
                                                svg.push(
                                                        `<circle cx="${nf(start.x)}" cy="${nf(start.y)}" r="${
                                                                this.debugPointRadius
                                                        }" fill="#000" stroke="none" />\n` +
                                                                `<circle cx="${nf(c1.x)}" cy="${nf(
                                                                        c1.y
                                                                )}" r="${
                                                                        this.debugPointRadius / 2
                                                                }" fill="#000" stroke="none" />\n` +
                                                                `<circle cx="${nf(c2.x)}" cy="${nf(
                                                                        c2.y
                                                                )}" r="${
                                                                        this.debugPointRadius / 2
                                                                }" fill="#000" stroke="none" />\n`
                                                );
                                        }
			}
		}
		svg.push('</svg>');
		return svg.join('');
	}

	/**
	 * Creates and initiates a download of the SVG generated by getSVGString.
	 * @param fileName - filename for the downloaded file
	 * @param backgroundColor - optional background color to include in the SVG
	 */
	public downloadSVG(fileName: string, backgroundColor?: Color): void {
		if (typeof document === 'undefined' || typeof window === 'undefined') {
			throw new Error('downloadSVG requires a browser environment');
		}

		if (fileName.slice(fileName.length - 4).toLowerCase() !== '.svg')
			fileName += '.svg';

		const svgText = this.getSVGString(backgroundColor);
		const blob = new Blob([svgText], {
			type: 'image/svg+xml;charset=utf-8',
		});
		const url = URL.createObjectURL(blob);

		const a = document.createElement('a');
		a.style.display = 'none';
		a.href = url;
		a.download = fileName;

		document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);

		// revoke the object URL after 10s to ensure the download finished.
		setTimeout(() => URL.revokeObjectURL(url), 10000);
	}

	private createHullsFromPalette(
		imageData: ImageDataLike,
		palette: Color[]
	): Hull[] {
		return palette
			.map(color => this.createHullsForColor(imageData, color))
			.flat()
			.filter(hull => hull.isValid);
	}

	private createHullsForColor(
		imageData: ImageDataLike,
		color: Color
	): Hull[] {
		const maskPoints = this.createMaskPointCloud(imageData, color);
		const pointClouds = this.separatePointClouds(maskPoints);
                return pointClouds.map(
                        pointCloud =>
                                new Hull(
                                        color,
                                        pointCloud,
                                        this.pathSimpMinDist,
                                        this.curveFittingTolerance,
                                        this.width,
                                        this.height
                                )
                );
        }

	private separatePointClouds(points: Vec2[]): Vec2[][] {
		const clouds: Vec2[][] = [];
		if (points.length === 0) return clouds;

		// Determine an effective threshold that respects both the configured minimum
		// hull distance and the sampling grid step size.
		const threshold = Math.max(0, this.minHullDistance);
		if (this.pixelGridStepSize > threshold) {
			throw new Error(
				'Pixel grid step needs to be smaller than the minimum hull distance.'
			);
		}

		// We'll compare squared Euclidean distances for the tight membership test.
		const thresholdSq = threshold * threshold;

		// Use a spatial hash (grid) to limit neighbor candidate checks.
		const cellSize = threshold; // one point of distance per cell is sufficient
		const grid = new Map<string, number[]>();
		for (let i = 0; i < points.length; i++) {
			const p = points[i];
			const cx = Math.floor(p.x / cellSize);
			const cy = Math.floor(p.y / cellSize);
			const key = `${cx},${cy}`;
			// set grid cell (or initialize first)
			(grid.get(key) ?? grid.set(key, []).get(key)!).push(i);
		}

		const visited = new Uint8Array(points.length);

		for (let i = 0; i < points.length; i++) {
			if (visited[i]) continue;

			// Start a new cloud
			const cloud: Vec2[] = [];
			const queue: number[] = [];
			let qi = 0;
			queue.push(i);
			visited[i] = 1;

			while (qi < queue.length) {
				const idx = queue[qi++];
				const p = points[idx];
				cloud.push(p);

				// Check neighboring grid cells (only need to check adjacent cells because
				// cellSize == threshold). This keeps candidate lookups small.
				const cx = Math.floor(p.x / cellSize);
				const cy = Math.floor(p.y / cellSize);
				for (let gx = cx - 1; gx <= cx + 1; gx++) {
					for (let gy = cy - 1; gy <= cy + 1; gy++) {
						const key = `${gx},${gy}`;
						const bucket = grid.get(key);
						if (!bucket) continue;
						for (const nbIdx of bucket) {
							if (visited[nbIdx]) continue;
							const q = points[nbIdx];
							const dx = q.x - p.x;
							const dy = q.y - p.y;

							// Fast reject: use Manhattan distance as a cheap filter
							// because points are integer grid samples. This avoids one
							// multiplication for far-away candidates.
							if (Math.abs(dx) + Math.abs(dy) > threshold * 2)
								continue;

							// Final check: squared Euclidean distance against threshold^2
							if (dx * dx + dy * dy <= thresholdSq) {
								visited[nbIdx] = 1;
								queue.push(nbIdx);
							}
						}
					}
				}
			}

			if (cloud.length) clouds.push(cloud);
		}

		return clouds;
	}

	private createMaskPointCloud(
		imageData: ImageDataLike,
		color: Color
	): Vec2[] {
		const { data, width, height } = imageData;
		const points: Vec2[] = [];
		const stride = this.pixelGridStepSize;

		for (let y = 0; y < height; y += stride) {
			for (let x = 0; x < width; x += stride) {
				const index = (y * width + x) * 4;
				if (this.pixelMatches(data, index, color)) {
					points.push({ x, y });
				}
			}
		}
		return points;
	}

	private pixelMatches(
		data: ArrayLike<number>,
		index: number,
		color: Color
	): boolean {
		return (
			data[index + 3] !== 0 && // alpha
			data[index] === color.r &&
			data[index + 1] === color.g &&
			data[index + 2] === color.b
		);
	}

	private colorsMatch(c1: Color, c2: Color): boolean {
		return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b;
	}
}
