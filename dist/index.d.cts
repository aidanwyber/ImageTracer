type Vec2 = {
    x: number;
    y: number;
};
type Color = {
    r: number;
    g: number;
    b: number;
};
interface ImageDataLike {
    data: ArrayLike<number>;
    width: number;
    height: number;
}
interface ImageTraceOptions {
    pathSimplificationTolerance: number;
    curveFittingTolerance: number;
    minHullDistance?: number;
    pixelGridStepSize?: number;
    debugPointRadius?: number;
}
declare enum PathSegmentType {
    Line = 0,
    Curve = 1
}
type PathSegment = {
    type: PathSegmentType.Line;
    points: [Vec2, Vec2];
} | {
    type: PathSegmentType.Curve;
    points: [Vec2, Vec2, Vec2, Vec2];
};
declare enum BoundarySide {
    Top = 0,
    Bottom = 1,
    Left = 2,
    Right = 3
}

declare class Hull {
    color: Color;
    readonly sampledPoints: Vec2[];
    readonly pathSimplification: number;
    readonly curveFittingTolerance: number;
    readonly width: number;
    readonly height: number;
    static concavity: number;
    readonly hullPoints: Vec2[];
    readonly pathSegments?: PathSegment[];
    readonly isValid: boolean;
    constructor(color: Color, sampledPoints: Vec2[], pathSimplification: number, curveFittingTolerance: number, width: number, height: number);
    /**
     * Reduces the number of points in a path while maintaining its shape
     */
    reducePoints(points: Vec2[], tolerance: number): Vec2[];
    createPathSegments(simplifiedHullPoints: Vec2[]): PathSegment[];
    private isBoundaryPoint;
    private getBoundarySides;
    private putOnSide;
    private isSamePoint;
    getPathData(): string;
    getPathElem(): string;
}

/**
 * ImageTrace converts raster images to vector graphics by detecting and tracing
 * color-matched regions into SVG paths.
 */
declare class ImageTrace {
    readonly width: number;
    readonly height: number;
    readonly curveFittingTolerance: number;
    readonly pathSimpMinDist: number;
    readonly pixelGridStepSize: number;
    readonly validHulls: Hull[];
    readonly minHullDistance: number;
    readonly debugPointRadius?: number;
    /**
     * Creates a new ImageTrace instance
     *
     * @param imageData - The source image data to trace
     * @param palette - Array of colors to match against
     * @param options - Configuration options for tracing
     * @throws {Error} If imageData or palette is invalid
     */
    constructor(imageData: ImageDataLike, palette: Color[], options: ImageTraceOptions);
    /**
     * Retrieves a hull by its color
     */
    getHullsByColor(color: Color): Hull[];
    /**
     * Generates an SVG string representation of the traced image
     * @param backgroundColor - optional background color to include in the SVG
     */
    getSVGString(backgroundColor?: Color): string;
    /**
     * Creates and initiates a download of the SVG generated by getSVGString.
     * @param fileName - filename for the downloaded file
     * @param backgroundColor - optional background color to include in the SVG
     */
    downloadSVG(fileName: string, backgroundColor?: Color): void;
    private createHullsFromPalette;
    private createHullsForColor;
    private separatePointClouds;
    private createMaskPointCloud;
    private pixelMatches;
    private colorsMatch;
}

declare function createConvexHullPoints(pointCloud: Vec2[]): Vec2[];

export { BoundarySide, type Color, Hull, type ImageDataLike, ImageTrace, type ImageTraceOptions, type PathSegment, PathSegmentType, type Vec2, createConvexHullPoints };
